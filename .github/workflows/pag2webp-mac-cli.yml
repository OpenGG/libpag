name: pag2webp-mac-cli

on:
  workflow_dispatch:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]

jobs:
  mac_cli_arm64:
    name: mac_cli_arm64
    runs-on: macos-latest

    steps:
      - name: Check Out Repo
        uses: actions/checkout@v4

      - name: Get Third-Party Cache
        id: third-party-cache
        uses: actions/cache/restore@v4
        with:
          path: third_party
          key: third-party-maccli-arm64-${{ hashFiles('DEPS') }}-${{ hashFiles('vendor.json') }}
          restore-keys: third-party-maccli-arm64-

      - name: Install deps (brew)
        shell: bash
        run: |
          brew update
          brew install cmake ninja yasm pkg-config webp

      - name: Install Build Tools
        shell: bash
        run: |
          chmod +x install_tools.sh
          ./install_tools.sh

      - name: Run depsync
        shell: bash
        run: |
          npm install depsync -g
          depsync

      # ------------------------------------------------------------
      # 1) Patch main.cpp -> PAG -> animated WebP CLI
      # ------------------------------------------------------------
      - name: Patch linux/src/main.cpp (PAG -> animated WebP)
        shell: bash
        run: |
          set -e
          cat > linux/src/main.cpp <<'CPP'
          #include <pag/file.h>
          #include <pag/pag.h>

          #include <webp/encode.h>
          #include <webp/mux.h>

          #include <algorithm>
          #include <cmath>
          #include <cstdint>
          #include <fstream>
          #include <iostream>
          #include <memory>
          #include <string>
          #include <vector>

          static void WriteFile(const std::string& path, const uint8_t* data, size_t size) {
            std::ofstream out(path, std::ios::binary);
            out.write(reinterpret_cast<const char*>(data), static_cast<std::streamsize>(size));
            out.close();
          }

          // libpag readPixels 返回 Premultiplied alpha，编码前建议反预乘，避免边缘发黑
          static void UnpremultiplyBGRA(uint8_t* bgra, int w, int h) {
            const int n = w * h;
            for (int i = 0; i < n; i++) {
              uint8_t* p = bgra + i * 4;  // B,G,R,A
              const int a = p[3];
              if (a == 0) {
                p[0] = p[1] = p[2] = 0;
                continue;
              }
              p[0] = (uint8_t)std::min(255, (p[0] * 255 + a / 2) / a);
              p[1] = (uint8_t)std::min(255, (p[1] * 255 + a / 2) / a);
              p[2] = (uint8_t)std::min(255, (p[2] * 255 + a / 2) / a);
            }
          }

          static const char* GetArg(int argc, char** argv, const char* key, const char* def = nullptr) {
            for (int i = 1; i + 1 < argc; i++) {
              if (std::string(argv[i]) == key) return argv[i + 1];
            }
            return def;
          }

          static bool HasFlag(int argc, char** argv, const char* key) {
            for (int i = 1; i < argc; i++) {
              if (std::string(argv[i]) == key) return true;
            }
            return false;
          }

          static void Usage() {
            std::cerr <<
          R"(Usage:
            pag2webp input.pag output.webp [options]

          Options:
            --fps N            override fps (default: PAG frameRate)
            --quality Q        0..100 (default: 75)
            --lossless 0|1     (default: 0)
            --loop N           0=infinite (default: 0)
            --no_unpremultiply disable unpremultiply (default: enabled)

          Example:
            pag2webp a.pag a.webp --quality 80 --loop 0
          )";
          }

          int main(int argc, char** argv) {
            if (argc < 3) {
              Usage();
              return 1;
            }

            const std::string inPath = argv[1];
            const std::string outPath = argv[2];

            const char* fpsStr = GetArg(argc, argv, "--fps", nullptr);
            const float fpsOverride = fpsStr ? std::stof(fpsStr) : 0.0f;

            const int quality = std::stoi(GetArg(argc, argv, "--quality", "75"));
            const int lossless = std::stoi(GetArg(argc, argv, "--lossless", "0"));
            const int loopCount = std::stoi(GetArg(argc, argv, "--loop", "0"));

            const bool doUnpremultiply = !HasFlag(argc, argv, "--no_unpremultiply");

            auto pagFile = pag::PAGFile::Load(inPath);
            if (!pagFile) {
              std::cerr << "Failed to load PAG: " << inPath << "\n";
              return 2;
            }

            const int w = pagFile->width();
            const int h = pagFile->height();
            const float fps = (fpsOverride > 0.0f) ? fpsOverride : pagFile->frameRate();

            const int64_t durationUs = pagFile->duration();
            const int64_t lastFrame = (int64_t)std::floor(durationUs * fps / 1000000.0);
            const int frameCount = (int)lastFrame + 1;

            auto surface = pag::PAGSurface::MakeOffscreen(w, h);
            if (!surface) {
              std::cerr << "MakeOffscreen failed\n";
              return 3;
            }

            auto player = std::make_unique<pag::PAGPlayer>();
            player->setSurface(surface);
            player->setComposition(pagFile);

            WebPAnimEncoderOptions enc_opts;
            WebPAnimEncoderOptionsInit(&enc_opts);
            enc_opts.anim_params.bgcolor = 0x00000000;
            enc_opts.anim_params.loop_count = loopCount;

            WebPAnimEncoder* enc = WebPAnimEncoderNew(w, h, &enc_opts);
            if (!enc) {
              std::cerr << "WebPAnimEncoderNew failed\n";
              return 4;
            }

            WebPConfig config;
            WebPConfigInit(&config);
            config.quality = (float)quality;
            config.lossless = lossless ? 1 : 0;
            config.method = 4;
            if (!WebPValidateConfig(&config)) {
              std::cerr << "Invalid WebP config\n";
              WebPAnimEncoderDelete(enc);
              return 5;
            }

            const int stride = w * 4;
            std::vector<uint8_t> pixels((size_t)stride * h);

            auto frameToMs = [&](int i) -> int {
              return (int)std::llround((double)i * 1000.0 / (double)fps);
            };

            for (int i = 0; i < frameCount; i++) {
              const double progress = (frameCount <= 1) ? 0.0 : ((double)i / (double)(frameCount - 1));
              player->setProgress(progress);
              player->flush();

              surface->readPixels(pag::ColorType::BGRA_8888,
                                  pag::AlphaType::Premultiplied,
                                  pixels.data(),
                                  stride);

              if (doUnpremultiply) {
                UnpremultiplyBGRA(pixels.data(), w, h);
              }

              WebPPicture pic;
              WebPPictureInit(&pic);
              pic.width = w;
              pic.height = h;
              pic.use_argb = 1;

              if (!WebPPictureImportBGRA(&pic, pixels.data(), stride)) {
                std::cerr << "WebPPictureImportBGRA failed at frame " << i << "\n";
                WebPPictureFree(&pic);
                WebPAnimEncoderDelete(enc);
                return 6;
              }

              const int ts = frameToMs(i);
              if (!WebPAnimEncoderAdd(enc, &pic, ts, &config)) {
                std::cerr << "WebPAnimEncoderAdd failed at frame " << i << "\n";
                WebPPictureFree(&pic);
                WebPAnimEncoderDelete(enc);
                return 7;
              }
              WebPPictureFree(&pic);
            }

            const int endTs = frameToMs(frameCount);
            WebPAnimEncoderAdd(enc, nullptr, endTs, nullptr);

            WebPData out;
            WebPDataInit(&out);
            if (!WebPAnimEncoderAssemble(enc, &out)) {
              std::cerr << "WebPAnimEncoderAssemble failed\n";
              WebPAnimEncoderDelete(enc);
              return 8;
            }

            WriteFile(outPath, out.bytes, out.size);
            WebPDataClear(&out);
            WebPAnimEncoderDelete(enc);

            std::cout << "OK: " << outPath << " (" << w << "x" << h
                      << ", fps=" << fps << ", frames=" << frameCount << ")\n";
            return 0;
          }
          CPP

      # ------------------------------------------------------------
      # 2) Patch CMakeLists: mac + libpag.a + swiftshader dylib + webp/webpmux
      # ------------------------------------------------------------
      - name: Patch linux/CMakeLists.txt (mac + webp)
        shell: bash
        run: |
          set -e
          cat > linux/CMakeLists.txt <<'CMAKE'
          cmake_minimum_required(VERSION 3.16)
          project(pag2webp LANGUAGES C CXX)
          set(CMAKE_CXX_STANDARD 17)

          add_definitions(-DSWIFTSHADER)
          add_definitions(-DGL_GLEXT_PROTOTYPES)
          add_definitions(-DEGL_EGLEXT_PROTOTYPES)

          if (NOT DEFINED PAG_ARCH)
            set(PAG_ARCH "arm64")
          endif()

          add_executable(pag2webp src/main.cpp)

          include_directories(${CMAKE_CURRENT_SOURCE_DIR}/vendor/libpag/include
                              src)

          if (APPLE AND NOT IOS)
            find_library(APPLICATION_SERVICES_FRAMEWORK ApplicationServices REQUIRED)
            find_library(QUARTZ_CORE QuartzCore REQUIRED)
            find_library(COCOA Cocoa REQUIRED)
            find_library(FOUNDATION Foundation REQUIRED)
            find_library(VIDEOTOOLBOX VideoToolbox)
            find_library(COMPRESSION_LIBRARIES NAMES compression)

            list(APPEND libs
              ${APPLICATION_SERVICES_FRAMEWORK}
              ${QUARTZ_CORE}
              ${COCOA}
              ${FOUNDATION}
              ${VIDEOTOOLBOX}
              ${COMPRESSION_LIBRARIES}
              ${CMAKE_CURRENT_SOURCE_DIR}/vendor/libpag/mac/${PAG_ARCH}/libpag.a
              ${CMAKE_CURRENT_SOURCE_DIR}/vendor/swiftshader/mac/${PAG_ARCH}/libEGL.dylib
              ${CMAKE_CURRENT_SOURCE_DIR}/vendor/swiftshader/mac/${PAG_ARCH}/libGLESv2.dylib
            )

            find_package(PkgConfig QUIET)
            if (PkgConfig_FOUND)
              pkg_check_modules(WEBP QUIET libwebp)
              pkg_check_modules(WEBPMUX QUIET libwebpmux)
            endif()

            if (WEBP_FOUND AND WEBPMUX_FOUND)
              include_directories(${WEBP_INCLUDE_DIRS} ${WEBPMUX_INCLUDE_DIRS})
              list(APPEND libs ${WEBP_LIBRARIES} ${WEBPMUX_LIBRARIES})
              add_link_options(${WEBP_LDFLAGS} ${WEBPMUX_LDFLAGS})
            else()
              find_library(WEBP_LIB NAMES webp)
              find_library(WEBPMUX_LIB NAMES webpmux)
              if (NOT WEBP_LIB OR NOT WEBPMUX_LIB)
                message(FATAL_ERROR "libwebp not found. Please: brew install webp")
              endif()
              list(APPEND libs ${WEBP_LIB} ${WEBPMUX_LIB})
            endif()

          else()
            message(FATAL_ERROR "This CMakeLists is intended to be used by mac CLI workflow.")
          endif()

          target_link_libraries(pag2webp ${libs})
          CMAKE

      # ------------------------------------------------------------
      # 3) Build libpag.a via build_pag + stage headers + stage swiftshader dylib
      # ------------------------------------------------------------
      - name: Build libpag (static) and stage vendor deps
        shell: bash
        run: |
          set -e
          ARCH="arm64"

          mkdir -p third_party/tgfx/out/cache
          mkdir -p linux/vendor/libpag/mac
          mkdir -p linux/vendor/libpag/include
          mkdir -p linux/vendor/swiftshader/mac/$ARCH

          node build_pag -p mac -a "$ARCH" \
            -DPAG_USE_SWIFTSHADER=ON \
            -DPAG_BUILD_SHARED=OFF \
            -DPAG_BUILD_FRAMEWORK=OFF \
            -o linux/vendor/libpag/mac

          rm -rf linux/vendor/libpag/include
          mkdir -p linux/vendor/libpag/include
          cp -a include/* linux/vendor/libpag/include/

          if [ ! -d "third_party/tgfx/vendor/swiftshader/mac/$ARCH" ]; then
            echo "SwiftShader dir not found: third_party/tgfx/vendor/swiftshader/mac/$ARCH"
            ls -la third_party/tgfx/vendor/swiftshader/mac || true
            exit 1
          fi
          cp -a third_party/tgfx/vendor/swiftshader/mac/$ARCH/* linux/vendor/swiftshader/mac/$ARCH/

          if [ ! -f "linux/vendor/libpag/mac/$ARCH/libpag.a" ]; then
            echo "Expected libpag.a missing: linux/vendor/libpag/mac/$ARCH/libpag.a"
            find linux/vendor/libpag/mac -maxdepth 6 -name libpag.a -print || true
            exit 1
          fi

          echo "== staged =="
          ls -la "linux/vendor/libpag/mac/$ARCH/libpag.a"
          ls -la "linux/vendor/swiftshader/mac/$ARCH/libEGL.dylib"
          ls -la "linux/vendor/swiftshader/mac/$ARCH/libGLESv2.dylib"

      # ------------------------------------------------------------
      # 4) Build CLI
      # ------------------------------------------------------------
      - name: Build pag2webp
        shell: bash
        run: |
          set -e
          export PKG_CONFIG_PATH="$(brew --prefix webp)/lib/pkgconfig:${PKG_CONFIG_PATH:-}"
          export MACOSX_DEPLOYMENT_TARGET="11.0"

          cmake -S linux -B linux/build_cli -G Ninja \
            -DCMAKE_BUILD_TYPE=Release \
            -DPAG_ARCH="arm64" \
            -DCMAKE_OSX_ARCHITECTURES="arm64" \
            -DCMAKE_OSX_DEPLOYMENT_TARGET="${MACOSX_DEPLOYMENT_TARGET}"

          cmake --build linux/build_cli --target pag2webp -j 8

      # ------------------------------------------------------------
      # 5) Package: copy dylibs (swiftshader + webp), rewrite install names, add rpath, ad-hoc codesign
      # ------------------------------------------------------------
      - name: Package portable (no brew needed on target mac)
        shell: bash
        run: |
          set -e
          ARCH="arm64"
          WEBP_PREFIX="$(brew --prefix webp)"

          rm -rf dist
          mkdir -p dist

          cp linux/build_cli/pag2webp dist/pag2webp
          chmod +x dist/pag2webp

          # SwiftShader (必需)
          cp "linux/vendor/swiftshader/mac/$ARCH/libEGL.dylib" dist/
          cp "linux/vendor/swiftshader/mac/$ARCH/libGLESv2.dylib" dist/

          # libwebp: 把 brew 的 dylib 一起带上（目标机无 brew 也能跑）
          # 不同版本可能有不同后缀，这里用通配符拷贝常见集合
          cp -a "$WEBP_PREFIX/lib"/libwebp*.dylib dist/ || true
          cp -a "$WEBP_PREFIX/lib"/libwebpmux*.dylib dist/ || true
          cp -a "$WEBP_PREFIX/lib"/libwebpdemux*.dylib dist/ || true
          cp -a "$WEBP_PREFIX/lib"/libsharpyuv*.dylib dist/ || true

          # 给可执行文件加 rpath：从自身目录找 dylib
          install_name_tool -add_rpath "@executable_path" dist/pag2webp || true

          # 统一所有 dylib 的 install id 为 @rpath/xxx.dylib
          for f in dist/*.dylib; do
            bn="$(basename "$f")"
            install_name_tool -id "@rpath/$bn" "$f" || true
          done

          # 把 pag2webp 里“绝对路径依赖”改成 @rpath/xxx
          while read -r dep; do
            [ -z "$dep" ] && continue
            case "$dep" in
              "$WEBP_PREFIX"/lib/*|/Users/runner/*|/private/var/*|/opt/homebrew/*)
                bn="$(basename "$dep")"
                if [ -f "dist/$bn" ]; then
                  install_name_tool -change "$dep" "@rpath/$bn" dist/pag2webp || true
                fi
              ;;
            esac
          done < <(otool -L dist/pag2webp | awk 'NR>1{print $1}')

          # 同理：把 dist 里 dylib 的依赖也改成 @rpath（避免它们继续引用 /opt/homebrew/...）
          for lib in dist/*.dylib; do
            while read -r dep; do
              [ -z "$dep" ] && continue
              case "$dep" in
                "$WEBP_PREFIX"/lib/*|/opt/homebrew/*|/Users/runner/*|/private/var/*)
                  bn="$(basename "$dep")"
                  if [ -f "dist/$bn" ]; then
                    install_name_tool -change "$dep" "@rpath/$bn" "$lib" || true
                  fi
                ;;
              esac
            done < <(otool -L "$lib" | awk 'NR>1{print $1}')
          done

          # ad-hoc codesign：install_name_tool 会破坏原签名，必须重签，否则有概率 dyld 拒绝加载
          codesign --force --sign - dist/pag2webp
          for f in dist/*.dylib; do
            codesign --force --sign - "$f" || true
          done

          # 便捷脚本（可选）
          cat > dist/run.sh <<'EOF'
          #!/usr/bin/env bash
          set -e
          DIR="$(cd "$(dirname "$0")" && pwd)"
          exec "$DIR/pag2webp" "$@"
          EOF
          chmod +x dist/run.sh

          echo "== otool -L pag2webp =="
          otool -L dist/pag2webp || true

          echo "== dist contents =="
          ls -la dist

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: pag2webp-mac-arm64-portable
          path: dist/*

      - name: Save Third-Party Cache
        if: ${{ (github.event_name == 'push') && (steps.third-party-cache.outputs.cache-hit != 'true') }}
        uses: actions/cache/save@v4
        with:
          path: third_party
          key: third-party-maccli-arm64-${{ hashFiles('DEPS') }}-${{ hashFiles('vendor.json') }}
